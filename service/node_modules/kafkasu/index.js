const { Kafka } = require('kafkajs');
const dotenv = require('dotenv');
const express = require('express');

dotenv.config();

class Broker {
    constructor(key, secret, server) {
        this.key = key
        this.secret = secret
        this.server = server
    }

    create(client) {
        const sasl = this.key && this.secret ? { username: this.key, password: this.secret, mechanism: 'plain' } : null
        const ssl = !!sasl
        return new Kafka({
            clientId: client,
            brokers: [this.server],
            ssl,
            sasl
        })
    }
}

const { KEY, SECRET, KAFKA_BOOTSTRAP_SERVER, CLIENT_ID } = process.env;
const broker = new Broker(KEY, SECRET, KAFKA_BOOTSTRAP_SERVER);
const kafka = broker.create(CLIENT_ID || 'kafka-client');

class Consumer {
    constructor(consumerConfig) {
        consumerConfig.groupId = consumerConfig.groupId || 'default-consumer-group';
        this.consumer = kafka.consumer(consumerConfig);
    }

    consume = async (topic, callback, fromBeginning = false) => {
        if (!topic) {
            callback(new Error('topic is required'), null);
        }
        try {
            await this.consumer.connect();
            await this.consumer.subscribe({
                topic,
                fromBeginning: fromBeginning
            });

            await this.consumer.run({
                eachMessage: async ({ topic, partition, message }) => {
                    const data = message.value.toString('utf-8');
                    callback(null, data);
                }
            });
        } catch (err) {
            callback(err, null);
        }
    }

    close = async () => {
        await this.consumer.disconnect();
    }
}

class Producer {
    constructor() {
        this.producer = kafka.producer();
    }

    async send(data, topic) {
        try {
            await this.producer.send({
                topic: topic,
                messages: [
                    {
                        value: JSON.stringify(data),
                    }
                ]
            })
        }
        catch (err) {
            console.log(err);
        }
    }

    produce = async (data, topic) => {
        if (!data) return console.log('No data to send');
        try {
            await this.producer.connect();
            await this.send(data, topic)
        } catch (err) {
            console.log(err);
        }
    }
}


class KafkaServer {
    constructor(server) {
        this.access = Kafka;
        this.consumers = {}
        this.producers = {}
        this.io = require('socket.io')(server, {
            cors: {
                origin: '*',
            }
        });
    }

    createConsumer(groupId) {
        this.consumers[groupId] = new Consumer({ groupId });
    }

    createProducer(topic) {
        this.producers[topic] = new Producer();
    }

    socketConsume(groupId, topic, event) {
        const socketConsumer = this.consumers[groupId];
        socketConsumer.consume(topic, (err, data) => {
            if (err) {
                console.log(err);
            } else {
                const value = data.toString('utf8');
                this.io.on('connection', (socket) => {
                    socket.emit(event, value)
                })
            }
        }).catch(error => {
            try {
                socketConsumer.consumer.disconnect();
                console.log(error);
            } catch (e) {
                console.error('connection error', e);
            }
            process.exit(1);
        })
    };

    consume = (groupId, topic, callback) => {
        const socketConsumer = this.consumers[groupId];
        socketConsumer.consume(topic, (err, data) => {
            if (err) {
                callback(err, null);
            } else {
                callback(null, data);
            }
        }).catch(error => {
            try {
                socketConsumer.consumer.disconnect();
                callback(error, null);
            } catch (e) {
                callback(e, null);
            }
            process.exit(1);
        })
    }

    fileProduce(data, topic) {
        const fileProducer = this.producers[topic];
        fileProducer.produce(data, topic);
    };

    socketProduce(event, topic) {
        const socketProducer = this.producers[topic];
        this.io.on('connection', (socket) => {
            socket.on(event, (data) => {
                socketProducer.produce(data, topic);
            });
        });
    };
}

class KafkaSu {
    constructor() {
        this.app = express();
        this.port = process.env.PORT || 9898;

        this.app.use(express.json());
        this.app.use(express.urlencoded({ extended: true }));

        //this.kafkaServer = new KafkaServer(this.app);
    }

    listen = () => {
        this.ioserver = this.app.listen(this.port, () => {
            console.log(`Server is running on port ${this.port}`);
        });
        this.kafkaServer = new KafkaServer(this.ioserver);
        return this.ioserver;
    }

    fetchSocket = (topic, groupId, eventName) => {

        // groupId = groupId || `${topic}-consumer-group`
        // eventName = eventName || `${topic}-event`

        this.kafkaServer.createProducer(topic);
        this.kafkaServer.createConsumer(groupId);
        this.kafkaServer.socketProduce(eventName, topic);
        this.kafkaServer.socketConsume(groupId, topic, eventName);
    }

    fetchFileSocket = (topic, fileData, groupId, eventName) => {
        this.kafkaServer.createProducer(topic);
        this.kafkaServer.createConsumer(groupId);
        this.kafkaServer.fileProduce(fileData, topic);
        this.kafkaServer.socketConsume(groupId, topic, eventName);
    }


    fetch = (topic, groupId, eventName, cb) => {
        this.kafkaServer.createProducer(topic);
        this.kafkaServer.createConsumer(groupId);
        this.kafkaServer.socketProduce(eventName, topic);
        this.kafkaServer.consume(groupId, topic, cb);
        this.kafkaServer.socketConsume(groupId, topic, eventName);
    }

    fetchFile = (topic, fileData, groupId, cb) => {
        this.kafkaServer.createProducer(topic);
        this.kafkaServer.createConsumer(groupId);
        this.kafkaServer.fileProduce(fileData, topic);
        this.kafkaServer.consume(groupId, topic, cb);
    }

    basicFetch = (topic, cb) => {
        var groupId = `${topic}-consumer-group`
        var eventName = `${topic}-event`
        this.fetch(topic, groupId, eventName, cb);
    }
    sendIo = (event, data) => {
        this.kafkaServer.io.on('connection', (socket) => {
            socket.emit(event, data)
        })
    }

}

module.exports = KafkaSu;